.386
.model flat, stdcall
option casemap :none
include includes\windows.inc
include includes\masm32.inc
include includes\kernel32.inc
include includes\macros\macros.asm
includelib includes\masm32.lib
includelib includes\kernel32.lib

	BSIZE equ 2
.data

	rez dd 0 ; Временный результат ввода десятичного числа
	gg1 dw 1111h
	aa dd BSIZE dup (?) ; два числа
	gg2 dw 2222h
	cc dd ? ; Сумма чисел
	gg3 dw 3333h
	soob_1 db "Enter the number: ", 0
	soob_2 db "Enter the second number: ", 0
	soob_3 db 0ah, 0dh, 0
	soob_0 db "Полученное число: ", 0
	soob_4 db "Proverka", 0	
	kol db 2h; Количество вводимых цифр
	num dw 0; Номер текущего вводимого числа числа
	counter dd 0
	
	stdout DWORD ? ;дескриптор вывода
	stdin DWORD ? ;дескриптор ввода
	
	cdkey DWORD ? ; Количество реально прочитанных конструкций из буфера (по 16 каждая)	

	buffer_key_2 db 0A0h dup (0) ; Буфер для вывода
	
.data?
	
	buffer_key_1 db 0A0h dup (?) ; Буфер для считывания конструкций из буфера ввода
		
.code
start:
	
	invoke AllocConsole ; запрашиваем у Windows консоль

	invoke GetStdHandle, STD_INPUT_HANDLE ; указатель на чтение из консоли
	mov stdin,eax ; указатель сохраняем в переменную	
	
	invoke GetStdHandle, STD_OUTPUT_HANDLE ; указатель на вывод в консоль
	mov stdout,eax ; указатель вывода сохраняем в переменную

	invoke WriteConsole, stdout, ADDR [soob_1], 20d, 0, 0 ; приглашение на ввод первого числа
		
@1:	
	
	invoke ReadConsoleInput, stdin, ADDR buffer_key_1, BSIZE, ADDR cdkey ; читаем все из консоли в буфер buffer_key_1

	cmp [buffer_key_1+10d], 0dh ; проверяется нажатие клавиши Enter
	je @2 ; если ENTER нажата, то выходим из цикла ввода
	
	cmp [buffer_key_1+14d], 0 ; если ничего не введено, то идем опять на опрос консоли
	je @1

	cmp [buffer_key_1+14d], 30h ; Если ввеженый код меньше кода цифры то на начало ввода
	jl @1 ; проверка если введеный код меньше кода цифры
	
	cmp [buffer_key_1+14d], 31h ; Если введеный код больше кода единицы, то опять на ввод
	jg @1  ; проверка переноса - его не будет если код больше кода единицы
	
	cmp [buffer_key_1+04d], 1h ; Если нажата клавиша - именно нажата!!!
	jne @1 ; условие - если не равно 1, то клавиша не нажата (может мышка, а может событи какое-то) - идти на опрос консоли
	
	invoke WriteConsole, stdout, ADDR [buffer_key_1+14d], 1, 0, 0 ; вывести символ нажатой клавиши (будут только цифры)
	
	xor eax, eax ; обнуляем регистр eax
	mov al, [buffer_key_1+14d] ; в самый младший байт регистра eax записываем код введеной цифры
	sub al, 30h ; преобразуем из кода в цифру
	
	jmp @1

@2:	
	
	invoke ReadConsoleInput, stdin, ADDR buffer_key_1, BSIZE, ADDR cdkey ; чистка буфера клавиатуры (читаем от туда все что есть)
	
	
	xor edi, edi
	mov di, num
	mov eax, rez
	mov rez, 0
	mov [aa + edi*4], eax
	inc di
	mov num, di
	sub kol, 1h
	jz @3		
			
	invoke WriteConsole, stdout, ADDR [soob_3], 2d, 0, 0 ; перейти на новую строку
	invoke WriteConsole, stdout, ADDR [soob_2], 27d, 0, 0 ; приглашение на ввод второго числа
	
	jmp @1
	
@3:
	mov edi, 0; обнулить di = необходим как счетчик для передвижения по ячейкам памяти массива aa
	xor ecx, ecx ; используется как счетсик количества оставщих итераций - показывает сколько чисел нужно еще обработать
	mov cx, num ; переменная имеет половину размера от ecx, поэтому можно записать только в cx (для этого весь ecx обнулялся ранее)
	xor eax, eax ; очистка регистра - будет использоваться для накопления суммы чисел
@4:		
	add eax, [aa + edi*4] ; сложение чисел - каждое число занимает 4 байта и поэтому коэффициент масштабирования выбран 4
	inc edi ; переход на следующее число - регистр показывает какое число будет обработано следующее
	dec ecx ; уменьшение количества обработанных чисел
	jnz @4 ; выполнять пока все числа не будут обработаны - пока счетчик количества не равен нулю
	
	xor ecx, ecx ; подготовка счетчика - обнуление
	xor edx, edx ; будет использоввн для приведения значения к размерности чисел
@5:	 	; деление числа на 10, чтобы представить его в десятичной системе счиления
				; будет браться остаток от деления и к нему прибавляться 30h, чтобы найти ASCII- код числа для вывода на экран
				; при делении первый остаток от деления дает нам правую цифру, которая должна быть выведена поседней
	add dl, 30h	; добавление 30h для нахождения кода числа (преобразвание в букву)
	push edx	; временное сохранение в стеке всех чисел - чтобы их перевернуть - сделать парвильный порядок символов
	xor edx, edx; обнуление edx, так как будет использовать у него только dl для записи только одной цифры
	inc ecx		; увеличение счетчика - сколько цифр- столько раз будет увеличен счетчик
	cmp eax, 0	; если делимое равно нулю (все остатки от деления найдены) то значить все цифры обработыны
	jne @5		; переход на обработку следующей цифры, если в регистре еще есть значение
				; если не равно, то переход
	
	mov edi, 0	; обнуление edi, который будет использоваться как счетчик для доступа к ячейкам
				; памяти куда будут записаны символы выводимых цифр для числа
@6:	
	pop edx		; чтение ASCII-кода цифры из стека (читается сначала старший разряд, так как он был помещен последним в стек)
	mov [buffer_key_2 + edi], dl ; по адресу буфера вывода сохраняем только один байт, соотвутствующий цифре
	inc edi		; переходим к следующему байту
	dec ecx		; уменьшаем счетчик-количество цифр в числе (был получен в предыдушщем цикле)
	jnz @6		; пока не обработаны все цифры чистаем из стека следующую цифру и ложем в буфер
				; пока не ноль - пока ecx больше нуля
	
	
	invoke WriteConsole, stdout, ADDR [soob_3], 2d, 0, 0 ; перейти на новую строку
	invoke WriteConsole, stdout, ADDR [soob_3], 2d, 0, 0 ; перейти на новую строку	
	invoke WriteConsole, stdout, ADDR [buffer_key_2], 27d, 0, 0 ; приглашение на ввод второго числа		
			
	exit		; конец основнйо пограммы - вызов прерывания выхода из процесса. Это директива компилятора.
				; это соответсвтует выхову макроса invoke ExitProcess, 0  
end start